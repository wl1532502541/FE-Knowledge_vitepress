import{_ as e,c as t,an as o,o as r}from"./chunks/framework.CkyLdKpM.js";const T=JSON.parse('{"title":"HTTP状态码","description":"","frontmatter":{},"headers":[],"relativePath":"计算机网络相关/HTTP状态码.md","filePath":"计算机网络相关/HTTP状态码.md","lastUpdated":1634152441000}'),d={name:"计算机网络相关/HTTP状态码.md"};function i(n,a,p,l,h,c){return r(),t("div",null,a[0]||(a[0]=[o('<h1 id="http状态码" tabindex="-1">HTTP状态码 <a class="header-anchor" href="#http状态码" aria-label="Permalink to &quot;HTTP状态码&quot;">​</a></h1><h3 id="_1xx" tabindex="-1">1XX <a class="header-anchor" href="#_1xx" aria-label="Permalink to &quot;1XX&quot;">​</a></h3><p>100 Continue：继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息。</p><h3 id="_2xx" tabindex="-1">2XX <a class="header-anchor" href="#_2xx" aria-label="Permalink to &quot;2XX&quot;">​</a></h3><p>200 OK：正常返回信息。例：对于GET，表示成功请求资源并返回。</p><p>201 Created：请求成功并且服务器创建了新的资源。</p><p>202 Accepted：服务器已接收请求，但尚未处理。</p><p>204 No Content：请求已经执行成功，但没有内容。若服务器拒绝对PUT、POST或者DELETE请求返回任何状态信息或表示，那么通常采用此响应代码。服务器也可以对GET请求返回此响应代码，这表明“客户端请求的资源存在，但其表示是空的”。注意与304(&quot;Not Modified&quot;)的区别。204常常用在Ajax应用里。服务器通过这个响应代码告诉客户端：客户端的输入已被接受，但客户端不应该改变任何UI元素。</p><h3 id="_3xx" tabindex="-1">3XX <a class="header-anchor" href="#_3xx" aria-label="Permalink to &quot;3XX&quot;">​</a></h3><p>301 Moved Permanently：请求的资源已经永久变了地址，永久重定向</p><p>302 Found： 请求的资源暂时变了地址，临时重定向。这个响应代码是造成大多数重定向方面的混乱的最根本原因。它应该是像307那样被处理。实际上，在HTTP 1.0中，响应代码302的名称是”Moved Temporarily”，不幸的是，在实际生活中，绝大多数客户端拿它像303一样处理。它的不同之处在于当服务器为客户端的PUT，POST或者DELETE请求返回302响应代码时，客户端要怎么做。为了消除这一混淆，在HTTP 1.1中，该响应代码被重命名为&quot;Found&quot;，并新加了一个响应代码307。这个响应代码目前仍在广泛使用，但它的含义市混淆的，所以我建议你的服务发送307或者303，而不要发送302.除非你知道正在与一个不能理解303或307的HTTP 1.0客户端交互。</p><p>303 See Other：临时性重定向，且总是使用 <code>GET</code> 请求新的 <code>URI</code>。返回一个响应文档的URI。</p><p>304 Not Modified：自从上次请求后，请求的网页未修改过。请求的资源命中协商缓存，即Etag未改变（服务端此资源的Etag==请求头里的If-Match里的Etag，即第一次拿到这个资源时拿到的Etag）或是资源最后更新时间未改变（服务端此资源最后更新时间==请求中的If-modified-since，即第一次拿到这个资源时拿到的Last-modified），这2个的优先级Etag高，因为资源更新时间以秒为单位，不如Etag精确反应文件改变</p><h3 id="_4xx" tabindex="-1">4XX <a class="header-anchor" href="#_4xx" aria-label="Permalink to &quot;4XX&quot;">​</a></h3><p>400 Bad Request：服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</p><p>401 Unauthorized：请求未授权。客户端试图对一个受保护的资源进行操作，却又没有提供正确的认证证书。客户端提供了错误的证书，或者根本没有提供证书。这里的证书（credential）可以是一个用户名/密码，也可以市一个API key，或者一个认证令牌。客户端常常通过向一个URI发送请求，并查看收到401响应，以获知应该发送哪种证书，以及证书的格式。如果服务器不想让未授权的用户获知某个资源的存在，那么它可以谎报一个404而不是401。这样做的缺点是：客户端需要事先知道服务器接受哪种认证--这将导致HTTP摘要认证无法工作。</p><p>403 Forbidden: 禁止访问。客户端请求的结构正确，但是服务器不想处理它。这跟证书不正确的情况不同--若证书不正确，应该发送响应代码401。该响应代码常用于一个资源只允许在特定时间段内访问，</p><p>或者允许特定IP地址的用户访问的情况。403暗示了所请求的资源确实存在。跟401一样，若服务器不想透露此信息，它可以谎报一个404。</p><p>404 Not Found：找不到与URI相匹配的资源</p><h3 id="_5xx" tabindex="-1">5XX <a class="header-anchor" href="#_5xx" aria-label="Permalink to &quot;5XX&quot;">​</a></h3><p>500 Internal Server Error：最常见的服务器端错误。对于大多数web框架，如果在执行请求处理代码时遇到了异常，它们就发送此响应代码。</p><p>503 Service Unavailable：服务器端暂时无法处理请求（可能是过载或维护）。</p>',22)]))}const x=e(d,[["render",i]]);export{T as __pageData,x as default};
